import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;


public class SudokuToCnf {
	public void generateCnf(String cnfFileName, int[][] sudokuAssignment, int N) throws IOException
	{
		int n = (int) Math.sqrt(N);
		int assignment = 0;
		//Count the number of assigned values
		for(int i=0;i<sudokuAssignment.length;i++)
		{
			for(int j=0;j<sudokuAssignment.length;j++)
			{
				if(sudokuAssignment[i][j]!=0)
				{
					assignment += 1;
				}
			}
		}
		// Create a .cnf file with the name provided
		BufferedWriter outputWriter = new BufferedWriter(new FileWriter(cnfFileName));
		// Print the 1st line of the .cnf file. 
		outputWriter.append("p cnf "+(N*N*N)+" "+ ((N*N)+(((N*N)*((N*(N-1))/2))*4)+assignment));
		outputWriter.newLine();
		
		// There is at least one number in each entry
		// There can be 1..9 possible entries for each cell in the N*N size Sudoku 
		// All the entries for the N*N cell are enumerated here
		// It will be N*N*N numbers each separated by a line corresponding to each cell of the Sudoku
		for(int i=0;i<N;i++)
		{
			for(int j=0;j<N;j++)
			{
				for(int k=1;k<=N;k++)
				{
					outputWriter.append(printEntry(i, j, k, N)+" ");
				}
				outputWriter.append("0");
				outputWriter.newLine();
			}
		}
		
		// There is at most one number in each entry
		// For each entry make sure that there is only one value per cell
		// As each cell can have a value of 1 to 9 , for each value of k, it cannot have any previous value of k
		// For example if 5 is placed in the 1st cell where row = 0 and column = 0
		// There will be no such entries generated by the conjunction of the following clauses:
		// -5 -1 and -5 -2 and -5 -3 and -5 -4
		// The same procedure is repeated for each of the 81 entries in the sudoku grid
		// As a result, there will be N*N*(N*(N-1))/2 clauses
		for(int i=0;i<N;i++)
		{
			for(int j=0;j<N;j++)
			{
				for(int k=1;k<=N;k++)
				{
					for(int p=1;p<k;p++)
					{
						
						outputWriter.append("-"+printEntry(i, j, k, N)+ " "+"-"+printEntry(i, j, p, N)+" 0");
						outputWriter.newLine();
					}
				}
			}
		}
		// Two cells in a row cannot be assigned the same value
		// In the previous case for each cell it was ensured that it can contain at most 1 value
		// The same logic is applied for each row
		// For example, if the 1st cell contains a 1 , where row and column number both are 0, then all 
		// the remaining columns 1 to 8 of row 0 cannot have a 1 .Hence, the following clauses are generated:
		// -10 -1 and -19 -1 and -28 -1 and -37 -1 and -46 -1 and -55 -1 and -64 -1 and -73 -1
		// In this case, there will also be N*N*(N*(N-1))/2 clauses
		for(int i=0;i<N;i++)
		{
			for(int j=1;j<=N;j++)
			{
				for(int k=0;k<N;k++)
				{
					for(int p=0;p<k;p++)
					{
						//System.out.println("-"+s[i][j][k]+ " "+"-"+s[p][j][k]+" 0");
						outputWriter.append("-"+printEntry(i, k, j, N)+ " "+"-"+printEntry(i, p, j, N)+" 0");
						outputWriter.newLine();
					}
				}
			}
		}
		// Two cells in a column cannot be assigned the same value
		// In the previous case for each cell it was ensured that it can contain at most 1 value
		// The same logic is applied for each column
		// For example, if the 1st cell contains a 1 , where row and column number both are 0, then all 
		// the remaining row 1 to 8 of column 0 cannot have a 1 .Hence, the following clauses are generated:
		// -82 -1 and -163 -1 and -244 -1 and -325 -1 and -406 -1 and -487 -1 and -568 -1 and -649 -1
		// In this case, there will also be N*N*(N*(N-1))/2 clauses
		for(int i=0;i<N;i++)
		{
			for(int j=1;j<=N;j++)
			{
				for(int k=0;k<N;k++)
				{
					for(int p=0;p<k;p++)
					{
						outputWriter.append("-"+printEntry(k, i, j, N)+ " "+"-"+printEntry(p, i, j, N)+" 0");
						outputWriter.newLine();
					}
				}
			}
		}
		// For each 3*3 size sub-block there can be only 1 assignment for k = 1 to N
		// Here, the 9*9 sudoku grid can be divided into 9 3*3 sized sub grids
		// if 1st sub-grids 1st cell (row =0 , column = 0) has any value from 1 to 9
		// Then the following clauses will be generated:
		// -10 -1 and -11 -2 and -12 -3 and -13 -4 and -14 -5 and -15 -6 and -16 -7 and -17 -8 and -18 -9
		// The procedure will be repeated for (-19 -1 and .. and -27 -9) and (-19 -10 and  ... and -27 -18) for the 1st row in the 1st 3*3 sub block
		// For the 2nd row and 1st column the following clauses will be generated:
		// -82 -1 and -83 -2 and -84 -3 and -85 -4 and -86 -5 and -87 -6 and -88 -7 and -89 -8 and -90 -9
		// It will be repeated for (-82 -10 and .. -90 -18) for 2nd row 1st column and 1st row 2nd column not being equal and on
		// In this case, there will also be N*N*(N*(N-1))/2 clauses
		for(int block=0;block<N;block++)
		{
			for(int c1 = 0;c1<N;c1++)
			{
				for(int c2=0;c2<c1;c2++)
				{
					for(int k=1;k<=N;k++)
					{
						outputWriter.append("-"+printEntry(setRow(block, c1, n), setCol(block, c1, n), k, N)+ " "+"-"+printEntry(setRow(block, c2, n), setCol(block, c2, n), k, N)+" 0");
						outputWriter.newLine();
					}
				}
			}
		}
		
		
		// Place the initial assignments to their appropriate positions
		for (int i=0; i<N; i++){
	        for (int j=0; j<N; j++){
	            if (sudokuAssignment[i][j] != 0){
	                
	            	outputWriter.append(""+printEntry(i, j, sudokuAssignment[i][j], N) + " 0");
	            	outputWriter.newLine();
	            }
	        }
	    }
		
		outputWriter.flush();
		outputWriter.close();
	}
	private int printEntry(int i,int j,int k,int n)
	/*
	 * Each cell of the N*N size sudoku can be printed as N*(N*row_number+column_number)+ cell_value 
	 * Here, row number is from 0 to N-1 (N rows)
	 * Column number is from 0 to N-1 (N columns)
	 * Each cell can have value from 1 to N 
	 */
	{
		return  (n*(n*i+j)+k);
	}
	/*
	*  For each sub grid of size 3*3 , here n is presumed as 3, this method returns the row number associated
	*  cell is the sub grid number. As in N*N size sudoku it will range from 0 to N-1.
	*  i stands for row number. Its value will also range from 0 to N-1
	*/
	private int setRow(int cell, int i, int n)
	{
		return (n*(cell / n)+(i/n));
	}
	/*
	*  For each sub grid of size 3*3 , here n is presumed as 3, this method returns the column number associated
	*  cell is the sub grid number. As in N*N size sudoku it will range from 0 to N-1.
	*  i stands for column number. Its value will also range from 0 to N-1
	*/
	private int setCol(int cell,int i,int n)
	{
		return (n*(cell%n)+(i%n));
	}

}
